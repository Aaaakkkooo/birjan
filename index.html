<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Объектно-ориентированное программирование</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
       
            <nav>
                <ul>
                    <li><a href="#hero">Главная</a></li>
                    <li><a href="#chapters">Главы</a></li>
                    <li><a href="#authors">Авторы</a></li>
                    <li><a href="#contacts">Контакты</a></li>
                </ul>
            </nav>
        </div>
    </header>
    <section id="hero" class="hero">
        <div class="container">
            <h1>Учись <span>Объектно-ориентированному программированию</span></h1>
            <div class="search-bar">
                <input type="text" placeholder="Искать по учебнику...">
                <button>Поиск</button>
            </div>
            <div class="features">
                <div class="feature-item">
                    <img src="coding.png" alt="Icon" >
                <button class="button" onclick="redirectToSite1()" >Полные главы и материалы</button>

    <script>
        function redirectToSite1() {
            window.location.href = 'https://coollib.in/g/comp_soft_dev_oop';
        }
    </script>
                </div> 
                <div class="feature-item">
                    <img src="gear.png" alt="Icon">
                    <button class="button" onclick="redirectToSite2()">Примеры и задачи</button>

    <script>
        function redirectToSite2() {
            window.location.href = 'https://www.exercisescsharp.com/oop/';
        }
    </script>
                </div>
                <div class="feature-item">
                    <img src="global.png" alt="Icon">
                    <button class="button" onclick="redirectToSite()">Теория</button>

    <script>
        function redirectToSite() {
            window.location.href = 'https://habr.com/ru/articles/463125/';
        }
    </script>
                </div>
            </div>
        </div>
    </section>
    <section id="chapters" class="chapters">
        <div class="container">
            <h2>Главы Учебника</h2>
            <div class="chapter-list">
                <div class="chapter-item">
                    <img src="technical-support.png" alt="Chapter 1">
                    <button onclick="toggleContent('OOP')">Введение в объектно-ориентированное программирование</button>
                    <div id="OOP" class="category-content">
                        <P>При изучении объектно-ориентированного программирования (ООП) наибольшей 
                            проблемой является использование новой терминологии и понимание нового подхода 
                            к решению старых задач - новой <i>технологии </i>программирования. Определения 
                            новых терминов и характеристики <i>методов</i> программирования составляют 
                            содержание данной темы.</P>
                        <p>Как в любом виде деятельности в программировании имеется своя <i>технология</i>: 
                            - это знания, правила, навыки и инструменты, позволяющие получать 
                            гарантированный качественный результат. Но само по себе соблюдение ряда правил 
                            не дает гарантию качества результата. Это объясняется спецификой 
                            программирования. Во-первых, это не наука, где знание какой-либо формулы 
                            позволяет однозначно решить задачу, подставив в нее исходные данные и получив 
                            результат. Во-вторых, эти правила необходимо соблюдать не столько на бумаге, 
                            сколько в голове. То есть технология программирования - это скорее способ 
                            организации процесса обдумывания программы, нежели ее записи. Из сказанного 
                            следует, что если пишущий программу - мыслит, то он уже придерживается какой-то 
                            технологии программирования, даже не подозревая об этом. Простейший метод 
                            заключается в написании программы сразу от начала до конца, без использования 
                            каких-либо общих принципов, то есть "как бог на душу положит".
                        </p>
                        <p>Рассмотрим наиболее известные из технологий:
                        </p>
                        <UL>
                            <LI>
                            метод "северо-западного" угла (имеется в виду лист бумаги или экран дисплея). 
                            Программа пишется сразу от начала до конца, без использования каких-либо общих 
                            принципов;
                            <LI>
                            технология структурного программирования, в ней предполагается придерживаться 
                            принципов модульности, нисходящего и пошагового проектирования программ, 
                            одновременного проектирования программ и структур данных.
                            <LI>
                                технология объектного программирования: связана с использованием при 
                                проектировании программы понятий объектов и их классов.</LI></UL>
                        <p><B>Парадигма программирования. </B>Что первично: алгоритм (процедура, функция) 
                            или обрабатываемые им данные? В традиционной технологии программирования 
                            взаимоотношения процедуры - данные имеют более-менее свободный характер, причем 
                            процедуры (функции) являются ведущими в этой связке: как правило, функция 
                            вызывает функцию, передавая данные друг - другу по цепочке. Соответственно, 
                            технология структурного проектирования программ прежде всего уделяет внимание 
                            разработке алгоритма.</p>
                        <p>В технологии ООП взаимоотношения данных и алгоритма имеют более регулярный 
                            характер: во-первых, класс (базовое понятие этой технологии) объединяет в себе 
                            данные (структурированная переменная) и методы (функции). Во-вторых, схема 
                            взаимодействия функций и данных принципиально иная. Метод (функция), вызываемый 
                            для одного объекта, как правило, не вызывает другую функцию непосредственно. 
                            Для начала он должен иметь доступ к другому объекту (создать, получить 
                            указатель, использовать внутренний объект в текущем и т.д.), после чего он уже 
                            может вызвать для него один из известных методов. Таким образом, структура 
                            программы определяется взаимодействием объектов различных классов между собой. 
                            Как правило, имеет место иерархия классов, а технология ООП иначе может быть 
                            названа как программирование "от класса к классу".</p>
                        <p><b>Модульное программирование.</b>Еще одной, но уже физической единицей 
                            программы является текстовый файл, содержащий некоторое количество функций и 
                            определений типов данных и переменных. Модульное программирование на уровне 
                            файлов - это возможность разделить полный текст программы на несколько файлов, 
                            транслировать их независимо друг от друга.</p>
                        <p>Принцип модульности распространяется не только на программы, но и на данные: 
                            любой набор параметров, характеризующих логический или физический объект, 
                            должен быть представлен в программе в виде единой структуры данных 
                            (структурированной переменной).</p>
                        <p>Олицетворением принципа модульности является библиотека стандартных функций. 
                            Она, как правило, обеспечивает полный набор параметризованных действий, 
                            используя общие структуры данных. Библиотеки представляют собой аналогичные 
                            Си-программы, независимо оттранслированные и помещенные в каталог библиотек.</p>
                        <p><b>Нисходящее программирование. </b>Нисходящее проектирование программы 
                            заключается в том, что разработка идет от общей неформальной формулировки 
                            некоторого действия программы на естественном языке, "от общего к частному": к 
                            замене ее одной из трех формальных конструкций языка программирования:</p>
                        <UL>
                            <LI>
                            простой последовательности действий;
                            <LI>
                                конструкции выбора или оператора
                                <span class="keyword">if</span>;
                            <LI>
                                конструкции повторения или цикла.</LI></UL>
                        <p>В записи алгоритма это соответствует движению от внешней (объемлющей) 
                            конструкции к внутренней (вложенной). Эти конструкции также могут содержать в 
                            своих частях неформальное описание действий, то есть нисходящее проектирование 
                            по своей природе является пошаговым. Отметим основные свойства такого подхода:</p>
                        <UL>
                            <LI>
                            первоначально программа формулируется в виде некоторого неформального действия 
                            на естественном языке;
                            <LI>
                            первоначально определяются входные параметры и результат действия;
                            <LI>
                            очередной шаг детализации не меняет структуру программы, полученную на 
                            предыдущих шагах;
                            <LI>
                            если в процессе проектирования получаются идентичные действия в различных 
                            ветвях, то это означает необходимость оформления этого действия отдельной 
                            функцией;
                            <LI>
                                необходимые структуры данных проектируются одновременно с детализацией 
                                программы.</LI></UL>
                        <p>В результате проектирования получается программа, в которой принципиально 
                            отсутствует оператор перехода goto, поэтому такая технология называется 
                            "программирование без
                            <span class="keyword">goto</span>".</p>
                        <p><b>Пошаговое программирование.</b> Нисходящее проектирование по своей природе 
                            является пошаговым, ибо предполагает каждый раз замену одной словесной 
                            формулировки на единственную конструкцию языка. Но в процессе разработки 
                            программы могут быть и другие шаги, связанные с детализацией самой словесной 
                            формулировки в более подробную.</p>
                        <p>То, что этот принцип выделен отдельно, говорит о необходимости предотвратить 
                            соблазн детализации программы сразу от начала до конца и развивать умение 
                            выделять и сосредоточивать внимание на главных, а не второстепенных деталях 
                            алгоритма.</p>
                        <p>Вообще нисходящее пошаговое проектирование программы не дает гарантии получения 
                            "правильной" программы, но позволяет возвратиться при обнаружении тупиковой 
                            ситуации к одному из верхних шагов детализации.</p>
                        <p><b>Структурное программирование.</b> При нисходящей пошаговой детализации 
                            программы необходимые для работы структуры данных и переменные появляются по 
                            мере перехода от неформальных определений к конструкциям языка, то есть 
                            процессы детализации алгоритма и данных идут параллельно. Однако это касается 
                            прежде всего отдельных локальных переменных и внутренних параметров. С самой же 
                            общей точки зрения предмет (в нашем случае - данные) всегда первичен по 
                            отношению к выполняемым с ним действиям (в нашем случае - алгоритм). Поэтому на 
                            самом деле способ организации данных в программе более существенно влияет на ее 
                            структуру алгоритма, чем что-либо другое, и процесс проектирования структур 
                            данных должен опережать процесс проектирования алгоритма их обработки.</p>
                        <p>Структурное программирование - модульное нисходящее пошаговое проектирование 
                            алгоритма и структур данных.</p>
                        <p><b>Понятия объекта, класса объектов. </b>Центральными в ООП являются понятия 
                            класса и объекта. Образно говоря, ООП заключается не столько в использовании 
                            классов и объектов в программе, сколько в замене принципа программирования "от 
                            функции к функции" принципом программирования "от класса к классу".</p>
                        <p>Технология ООП прежде всего накладывает ограничения на способы представления 
                            данных в программе. Любая программа отражает в них состояние физических 
                            предметов либо абстрактных понятий (назовем их объектами программирования), для 
                            работы с которыми она предназначена. В традиционной технологии варианты 
                            представления данных могут быть разными. В худшем случае программист может 
                            "равномерно размазать" данные о некотором объекте программирования по всей 
                            программе. В противоположность этому все данные об объекте программирования и 
                            его связях с другими объектами можно объединить в одну структурированную 
                            переменную. В первом приближении ее можно назвать <i>объектом</i>. Кроме того, 
                            с объектом связывается набор действий, иначе называемых <i>методами</i>. С 
                            точки зрения языка программирования это функции, получающие в качестве 
                            обязательного параметра указатель на объект. Технология ООП запрещает работать 
                            с объектом иначе, чем через методы, то есть внутренняя структура объекта скрыта 
                            от внешнего пользователя. Описание множества однотипных объектов называется <i>классом</i>.
                        </p>
                        <p><i>Объект - структурированная переменная, содержащая всю информацию о некотором 
                                физическом предмете или реализуемом в программе понятии.</i></p>
                        <p><i>Класс - описание множества таких объектов и выполняемых над ними действий.</i></p>
                        <p>Это определение можно проиллюстрировать средствами классического Си:</p>
                        <pre>struct MyClass
                {
                int data1;
                ...
                };
                
                void method1(struct MyClass *this,...)
                { ... this-&gt;data1 ... }
                
                void method2(struct MyClass *this,...)
                { ... this-&gt;data1 ... }
                
                struct MyClass obj1, obj2;
                
                ... method1(&amp;obj1,...); ... method2(&amp;obj2,...);</pre>
                        <p>В синтаксисе классического Си зафиксирован перечень базовых типов данных и 
                            операций над ними. Переменные производных типов данных, в том числе и 
                            структуры, могут обрабатываться только с использованием выражений (функций).В 
                            Си++ класс обладает синтаксическими свойствами базового типа данных:</p>
                        <UL>
                            <LI>
                                класс определяется как структурированный тип данных (<span class="keyword">struct</span>);
                            <LI>
                            объекты определяются как переменные класса;
                            <LI>
                                возможно переопределение и использование стандартных операций языка, имеющих в 
                                качестве операндов объекты класса, в виде особых методов в этом классе.</LI></UL>
                        <pre><font face="Courier New" size=3>struct Matrix
                {
                // определение структурированного типа matrix и методов,
                // реализующих операции Matrix * Matrix, Matrix * double
                }
                
                Matrix a,b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // Определение переменных и
                double dd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // объектов класса Matrix
                a = a * b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  // Использование переопределенных
                b = b * dd * 5.0;&nbsp;// операций</font></pre>
                        <p><i>Класс - определенный программистом базовый тип данных. </i>
                        </p>
                        <p><i>Объект - переменная класса. </i>
                        </p>
                        <p><b>Основные понятия объектно-ориентированного программирования:</b><b>инкапсуляция, 
                                наследование и полиморфизм. </b>"Эпизодическое" использование технологии 
                            ООП заключается в разработке отдельных, не связанных между собой классов и 
                            использовании их как необходимых программисту базовых типов данных, 
                            отсутствующих в языке. При этом общая структура программы остается 
                            традиционной. ("от функции к функции").
                        </p>
                        <p>Объектно-ориентированное программирование (ООП) это совокупность понятий (класс, 
                            объект, инкапсуляция, полиморфизм, наследование), приемов их использования при 
                            проектировании программ, а Си++ - инструмент этой технологии.
                        </p>
                        <p>Строгое следование технологии ООП предполагает, что любая функция в программе 
                            представляет собой метод для объекта некоторого класса. Это не означает, что 
                            нужно вводить в программу какие попало классы ради того, чтобы написать 
                            необходимые для работы функции. Наоборот, класс должен формироваться в 
                            программе естественным образом, как только в ней возникает необходимость 
                            описания новых физических предметов или абстрактных понятий (объектов 
                            программирования). С другой стороны, каждый новый шаг в разработке алгоритма 
                            также должен представлять собой разработку нового класса на основе уже 
                            существующих. В конце концов вся программа в таком виде представляет собой 
                            объект некоторого класса с единственным методом run (выполнить). Именно этот 
                            переход (а не понятия класса и объекта, как таковые) создает психологический 
                            барьер перед программистом, осваивающим технологию ООП.
                        </p>
                        <p>Программирование "от класса к классу" включает в себя ряд новых понятий. Прежде 
                            всего, это - <i>инкапсуляция данных</i>, то есть логическое связывание данных с 
                            конкретной операцией. Инкапсуляция данных означает, что данные являются не 
                            глобальными - доступными всей программе, а локальными - доступными только малой 
                            ее части. Инкапсуляция автоматически подразумевает защиту данных. Для этого в 
                            структуре class используется спецификатор раздела private, содержащий данные и 
                            методы, доступные только для самого класса. Если данные и методы содержатся в 
                            разделе public, они доступны извне класса. Раздел protected содержит данные и 
                            методы, доступные из класса и любого его <i>производного класса</i>. Наличие 
                            последних позволяет говорить об иерархии классов, где есть классы - родители - 
                            шаблоны для создания классов - потомков. Объекты, полученные из описания 
                            класса, называют <i>экземплярами</i> этого класса.</p>
                        <p>Вторым по значимости понятием является <i>наследование</i>. Новый, или <i>производный 
                                класс</i> может быть определен на основе уже имеющегося, или базового. При 
                            этом новый класс сохраняет все свойства старого: данные объекта базового класса 
                            включаются в данные объекта производного, а методы базового класса могут быть 
                            вызваны для объекта производного класса, причем они будут выполняться над 
                            данными включенного в него объекта базового класса. Иначе говоря, новый класс 
                            наследует как данные старого класса, так и методы их обработки. Если объект 
                            наследует свои свойства от одного родителя, то говорят об <i>одиночном наследовании</i>. 
                            Если же объект наследует атрибуты от нескольких базовых классов, то говорят о <i>множественном 
                                наследовании</i>. Простой пример наследования - определение структуры, 
                            отдельный член которой является ранее определенной структурой.</p>
                        <p>Третьим по значимости понятием является <i>полиморфизм</i>. Он основывается на 
                            возможности включения в данные объекта также и информации о методах их 
                            обработки (в виде указателей на функции). Принципиально важно, что такой объект 
                            становится "самодостаточным". Будучи доступным в некоторой точке программы, 
                            даже при отсутствии полной информации о его типе, он всегда может корректно 
                            вызвать свойственные ему методы. <i>Полиморфной</i> называется функция, 
                            независимо определенная в каждом из группы производных классов и имеющая в них 
                            общее имя. Полиморфная функция обладает тем свойством, что при отсутствии 
                            полной информации о том, объект какого из производных классов в данный момент 
                            обрабатывается, она тем не менее корректно вызывается в том виде, к каком она 
                            была определена для данного конкретного класса. Практический смысл полиморфизма 
                            заключается в том, что он позволяет посылать общее сообщение о сборе данных 
                            любому классу, причем и родительский класс, и классы-потомки ответят на 
                            сообщение соответствующим образом, поскольку производные классы содержат 
                            дополнительную информацию. Программист может сделать регулярным процесс 
                            обработки несовместимых объектов различных типов при наличии у них такого 
                            полиморфного метода.
                        </p>
                        <p>Полиморфный метод в Си++ называется <i>виртуальной функцией</i>, позволяющей 
                            получать ответы на сообщения, адресованные объектам, точный вид которых 
                            неизвестен. Такая возможность является результатом <i>позднего связывания</i>. 
                            При позднем связывании адреса определяются динамически во время выполнения 
                            программы, а не статически во время компиляции, как в традиционных 
                            компилируемых языках, в которых применяется <i>раннее связывание</i>. Сам 
                            процесс связывания заключается в замене виртуальных функций на адреса памяти.
                        </p>
                        <p>Виртуальные функции определяются в родительском классе, а в производных классах 
                            происходит их доопределение и для них создаются новые реализации. При работе с 
                            виртуальными функциями сообщения передаются как указатели, которые указывают на 
                            объект вместо прямой передачи объекту. Виртуальные функции используют таблицу 
                            для адресной информации, которая инициализируется при выполнения при помощи 
                            конструктора.
                        </p>
                    </div>
                </div>
                <div class="chapter-item">
                    <img src="it-service.png" alt="Chapter 2">
                    <button onclick="toggleContent('obt')">Классы и Объекты</button>
                    <div id="obt" class="category-content">
                        <h1 class="article__title md-title">
                            Что такое классы в объектно-ориентированном программировании
                            </h1>
                            <h2 class="article__subtitle sm-title">
                            Объясняем базовые понятия.
                            </h2>
                            <section class="article__body" id="article-body">
                            <p>Обучение почти каждому языку программирования начинается с создания классов и объектов. Они помогают в работе с базами данных, в автоматическом тестировании, а также позволяют не писать много раз одинаковый код.&nbsp;</p>
                            <p>Рассказываем, что такое классы в объектно-ориентированных языках, по каким принципам работают и чем отличаются.</p>

                            <h2>Зачем нужны классы в программировании</h2>
                            <p>ООП &mdash; это способ написания программ, где структуру создают из объектов, которые взаимодействуют между собой. На базе ООП построены языки Java, Swift, Python, PHP, JavaScript и Ruby.&nbsp;</p>
                            <p>Основа ООП &mdash; класс &mdash; способ отобразить предмет реального мира с помощью атрибутов. Например, множество классов используют как &laquo;чертежи&raquo; для компьютерного отображения домов, машин, деревьев, животных и любых других объектов, которые нужно смоделировать. Класс в программировании состоит из данных и кода. Данные отображают предметы или абстрактные понятия, а код ими управляет.&nbsp;</p>
                            <p>Класс ООП имеет набор атрибутов и характеристик. Каждая характеристика &mdash; это поле класса. Взаимодействовать с полями позволяют методы класса &mdash; операторы и функции для определенного действия.</p>
                            <p>Если в ООП есть задача описать реальный объект &mdash; например, книгу &mdash; вы должны задать ее характеристики (свойства объекта): цвет, размер, автор, год выпуска, жанр. У книги есть и функции: выдача текстовой или графической информации.</p>
                            <p>Задав программе характеристики и функции, мы обобщили данные и создали объект. Если мы знаем, что множество книг соответствует характеристикам, то можем использовать объект как шаблон для создания других. Шаблон, который задает начальные характеристики для объектов, &mdash; это и есть класс.</p>
                            <p>ООП позволяет разбить сложные задачи на простые и не прописывать функции для каждого объекта.</p>
                           
                            <h2>Как работают классы</h2>
                            <p>ООП построен на четырех основных принципах: абстрагирование, полиморфизм, наследование и инкапсуляция.&nbsp;</p>
                            <p>Абстрагирование &mdash; это отсечение несущественных характеристик для класса и прописывание ключевых. Например, и для класса Car, и для класса Plane можно указать то, что они сделаны из металла, но это не ключевая характеристика, а вот способность ездить (для первого класса) и летать (для второго) &mdash; существенная. Идея абстрагирования в том, чтобы задать минимум полей для объекта, оставив важные.&nbsp;</p>
                            <p>Идея наследования состоит в передаче характеристик от одного класса к другому, у которого есть также и свои характеристики. Классы, на основе которых создаются другие, называются родительскими или суперклассами. Те, которые унаследовали характеристики, &mdash; классами-потомками или подклассами.</p>
                            <p>Например, компания собирается в 2022 году выпустить в производство новую серию ноутбуков с улучшенными видеокартами, процессорами и большим объемом памяти. Но разрабатывать модель с нуля долго. Если в компании уже есть линейка, которая отвечает запросам (суперкласс Laptops), то класс NewLaptops унаследует атрибуты суперкласса и к нему лишь добавят новые характеристики.</p>
                            <p>Для разграничения доступа к объектам используется инкапсуляция. Это способ объединения данных, который запрещает доступ части компонентов программы к другим ее фрагментам. Он позволяет работать с частью программы и не запускать ненужные в этом участке кода функции. Класс NewLaptops отображает для юзера пользовательский интерфейс ноутбука, но будет скрывать ненужные сведения. Например, как операционная система распределяет время процессора для решения задач.&nbsp;&nbsp;&nbsp;</p>
                            <p>Идею полиморфизма кратко описывают так: &laquo;один интерфейс &mdash; множество реализаций&raquo; &mdash; с помощью одной функции можно обработать данные, принадлежащие к разным классам. Если компания производит разную технику с видеокамерами, код, который описывает свойства камеры, будет подходить для нескольких классов. Например, NewLaptops и Phones.</p>
                            <div class="render-related-course"><section class="teachers-cards">
                            <div class="container">
                            <p class="teachers-cards__title"></p>
                            <section class="teachers-cards__wrapper">
                            <article class="teachers-cards__card">
                            <div class="teachers-cards__card--content">
                            <div class="teachers-cards__card--content-container">
                            <p class="teachers-cards__card--specialty"></p>
                            <p class="teachers-cards__card--full-name"></p>
                            <p class="teachers-cards__card--description">
                           
                            </p>
                            </div>
                            <a href="/course/algoritmy-i-struktury-dannyh" class="btn btn--white">
                            
                           
                            </a>
                            </div>
                           
                            </article>
                            </section>
                            </div>
                            </section></div>
                    </div>
                </div>
                <div class="chapter-item">
                    <img src="software-application.png" alt="Chapter 3">
                    <button onclick="toggleContent('nas')">Наследование</button>
                    <div id="nas" class="category-content">
                        <p>Все классы, которые мы рассматривали до этого, создавались &quot;с нуля&quot;. И до тех пор, пока описываемые классами сущности мало похожи друг на друга, создание абсолютно новых классов работает отлично. Но что делать, если мы хотим, чтобы пара классов содержала один и тот же метод — не одноименный, а именно копию?</p><p>Конечно же, мы можем при объявлении класса вместо объявления метода по месту поместить в атрибут ссылку на существующую функцию. И это даже сработает! Но когда таковых методов станет несколько, уследить за тем, что и куда копируется, станет очень сложно. К счастью, есть способ лучше!</p><p>Языки, реализующие инструментарий для объектно ориентированного программирования, включая использование классов, предоставляют и механизм <em>наследования</em>. Python — один из таких языков. Поэтому классы в Python можно <em>наследовать</em>.</p><p>Когда один класс становится наследником другого, то все атрибуты <em>класса-предка (надкласса, superclass)</em> становятся доступны <em>классу-потомку (подклассу, subclass)</em> — наследуются (достаются в наследство).</p>
                    </div>
                </div>
                <div class="chapter-item">
                    <img src="information-technology.png" alt="Chapter 4">
                    <button onclick="toggleContent('pol')">Полиморфизм</button>
                    <div id="pol" class="category-content">
                        <p>Полиморфизм в объектно-ориентированном программировании – это возможность обработки разных типов данных, т. е. принадлежащих к разным классам, с помощью "одной и той же" функции, или метода. На самом деле одинаковым является только имя метода, его исходный код зависит от класса. Кроме того, результаты работы одноименных методов могут существенно различаться. Поэтому в данном контексте под полиморфизмом понимается множество форм одного и того же слова – имени метода.</p>

                    </div>
                </div>
                
            </div>
        </div>
    </section>
    <div class="video-container">
        <iframe width="560" height="315" src="https://www.youtube.com/embed/-6DWwR_R4Xk?si=9GoppQ0PyS8l4zL6" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </div>
    
    <section id="authors" class="categories">
        <div class="container">
            <h2>Темы</h2>
            <div class="category-list">
                <button onclick="toggleContent('concepts')">Концепции</button>
                <button onclick="toggleContent('examples')">Примеры</button>
                <button onclick="toggleContent('practice')">Практика</button>
                <button onclick="toggleContent('code')">Код</button>
                <button onclick="toggleContent('theory')">Теория</button>
            </div>
            <div id="concepts" class="category-content">
                <p>4 концепции ООП: полиморфизм, абстракция, инкапсуляция и наследование</p>
            </div>
            <div id="examples" class="category-content" style="display:none;">
                <p>Пример: Уровень заряда батареи смартфона

                    <pre><code class="cs"><span class="ͼ4">public</span> <span class="ͼ4">class</span> <span class="ͼ5">MusicApp</span><br>{<br>    <span class="ͼ4">private</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span> <span class="ͼ5">_favoriteSongs</span> <span class="ͼ6">=</span> <span class="ͼ4">new</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span>();<br><br>    <span class="ͼ4">public</span> <span class="ͼ4">void</span> <span class="ͼ5">AddToFavorites</span>(<span class="ͼ4">string</span> <span class="ͼ5">songName</span>)<br>    {<br>        <span class="ͼ4">if</span>(<span class="ͼ6">!</span><span class="ͼ4">string</span>.<span class="ͼ5">IsNullOrEmpty</span>(<span class="ͼ5">songName</span>) <span class="ͼ6">&amp;&amp;</span> <span class="ͼ6">!</span><span class="ͼ5">_favoriteSongs</span>.<span class="ͼ5">Contains</span>(<span class="ͼ5">songName</span>))<br>        {<br>            <span class="ͼ5">_favoriteSongs</span>.<span class="ͼ5">Add</span>(<span class="ͼ5">songName</span>);<br>        }<br>    }<br><br>    <span class="ͼ4">public</span> <span class="ͼ4">void</span> <span class="ͼ5">RemoveFromFavorites</span>(<span class="ͼ4">string</span> <span class="ͼ5">songName</span>)<br>    {<br>        <span class="ͼ5">_favoriteSongs</span>.<span class="ͼ5">Remove</span>(<span class="ͼ5">songName</span>);<br>    }<br><br>    <span class="ͼ4">public</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span> <span class="ͼ5">GetFavorites</span>()<br>    {<br>        <span class="ͼ4">return</span> <span class="ͼ4">new</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span>(<span class="ͼ5">_favoriteSongs</span>);<br>    }<br>}</code></pre>
                    Здесь _batteryLife — это наши важные данные. У нас есть методы для зарядки и показа текущего значения, однако мы не даем доступ к самой переменной _batteryLife, поэтому, например, пользователи класса не смогут убавить значение нашей переменной.</p>
                    <p>Пример: Избранные песни

                        Давайте представим музыкальное приложение, в котором можно добавлять или удалять песни из своего списка избранного.
                        
                        <pre><code class="cs"><span class="ͼ4">public</span> <span class="ͼ4">class</span> <span class="ͼ5">SocialMediaPlatform</span><br>{<br>    <span class="ͼ4">private</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span> <span class="ͼ5">_privateMessages</span> <span class="ͼ6">=</span> <span class="ͼ4">new</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span>();<br><br>    <span class="ͼ4">public</span> <span class="ͼ4">void</span> <span class="ͼ5">SendMessage</span>(<span class="ͼ4">string</span> <span class="ͼ5">message</span>)<br>    {<br>        <span class="ͼ4">if</span>(<span class="ͼ6">!</span><span class="ͼ4">string</span>.<span class="ͼ5">IsNullOrEmpty</span>(<span class="ͼ5">message</span>))<br>        {<br>            <span class="ͼ5">_privateMessages</span>.<span class="ͼ5">Add</span>(<span class="ͼ5">message</span>);<br>        }<br>    }<br><br>    <span class="ͼ4">public</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span> <span class="ͼ5">ShowMyMessages</span>()<br>    {<br>        <span class="ͼ4">return</span> <span class="ͼ4">new</span> <span class="ͼ5">List</span><span class="ͼ6">&lt;</span><span class="ͼ4">string</span><span class="ͼ6">&gt;</span>(<span class="ͼ5">_privateMessages</span>);<br>    }<br>}</code></pre>
                        В этом примере инкапсулирован, то есть спрятан от доступа извне класса, список наших избранных песен (_favoriteSongs). Мы предоставляем методы для управления списком, но не даем возможности работать со списком напрямую.</p>
            </div>
            <div id="practice" class="category-content" style="display:none;">
                <p><a href="https://metanit.com/sharp/tutorial/3.29.php">Практика 1</a></p>
                <br>
                <p><a href="https://gist.github.com/disolovyov/1198792">Практика 2</a></p>
                <br>
                <p><a href="https://www.examclouds.com/ru/java/java-core-russian/lesson7-tasks">Практика 3</a></p>
                <br>
                <p><a href="https://pythonworld.ru/osnovy/obektno-orientirovannoe-programmirovanie-obshhee-predstavlenie.html">Практика 4</a></p>
            </div>
            <div id="code" class="category-content" style="display:none;">
                <p><pre class="flex overflow-y-auto px-16 py-12 language-python" tabindex="0"><code class="language-python"><span class="token keyword">class</span> Дверь<span class="token punctuation">:</span>
                    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> размер<span class="token punctuation">,</span> материал<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>размер <span class="token operator">=</span> размер
                        self<span class="token punctuation">.</span>материал <span class="token operator">=</span> материал
                
                    <span class="token keyword">def</span> открыть<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Дверь открыта"</span><span class="token punctuation">)</span>
                
                    <span class="token keyword">def</span> закрыть<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Дверь закрыта"</span><span class="token punctuation">)</span>
                
                <span class="token keyword">class</span> Окно<span class="token punctuation">:</span>
                    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> размер<span class="token punctuation">,</span> материал<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        self<span class="token punctuation">.</span>размер <span class="token operator">=</span> размер
                        self<span class="token punctuation">.</span>материал <span class="token operator">=</span> материал
                
                    <span class="token keyword">def</span> открыть<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Окно открыто"</span><span class="token punctuation">)</span>
                
                    <span class="token keyword">def</span> закрыть<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
                        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Окно закрыто"</span><span class="token punctuation">)</span>
                
                <span class="token comment"># Создаем объекты</span>
                дверь_гостиной <span class="token operator">=</span> Дверь<span class="token punctuation">(</span><span class="token string">"200x80"</span><span class="token punctuation">,</span> <span class="token string">"Дерево"</span><span class="token punctuation">)</span>
                окно_кухни <span class="token operator">=</span> Окно<span class="token punctuation">(</span><span class="token string">"150x150"</span><span class="token punctuation">,</span> <span class="token string">"Пластик"</span><span class="token punctuation">)</span>
                
                <span class="token comment"># Используем методы объектов</span>
                дверь_гостиной<span class="token punctuation">.</span>открыть<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Дверь открыта</span>
                окно_кухни<span class="token punctuation">.</span>закрыть<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># Окно закрыто</span></code></pre></p>
                <br>
                <br>
                <br>
                <p><pre><code class="cs"><span class="ͼ8">// объявление класса с помощью ключевого слова class</span><br><span class="ͼ4">class</span> <span class="ͼ5">Transformer</span>(){<br>    <span class="ͼ8">// объявление поля x</span><br>    <span class="ͼ4">int</span> <span class="ͼ5">x</span><br><br>    <span class="ͼ8">// объявление метода конструктора (сюда нам чуть ниже передадут 0)</span><br>    <span class="ͼ5">function</span> <span class="ͼ5">constructor</span>(<span class="ͼ4">int</span> <span class="ͼ5">x</span>){<br>        <span class="ͼ8">// инициализация поля x </span><br>        <span class="ͼ8">// (переданный конструктору 0 превращается в свойство объекта)</span><br>        <span class="ͼ4">this</span>.<span class="ͼ5">x</span> <span class="ͼ6">=</span> <span class="ͼ5">x</span><br>    }<br>	<br>    <span class="ͼ8">// объявление метода run</span><br>    <span class="ͼ5">function</span> <span class="ͼ5">run</span>(){<br>        <span class="ͼ8">// обращение к собственному атрибуту через this</span><br>        <span class="ͼ4">this</span>.<span class="ͼ5">x</span> <span class="ͼ6">+=</span> <span class="ͼ9">1</span><br>    }<br>}<br><br><span class="ͼ8">// а теперь клиентский код:</span><br><br><span class="ͼ8">// создаем новый экземпляр трансформера с начальной позицией 0</span><br><span class="ͼ5">optimus</span> <span class="ͼ6">=</span> <span class="ͼ4">new</span> <span class="ͼ5">Transformer</span>(<span class="ͼ9">0</span>)<br><br><span class="ͼ5">optimus</span>.<span class="ͼ5">run</span>() <span class="ͼ8">// приказываем Оптимусу бежать</span><br><span class="ͼ5">print</span> <span class="ͼ5">optimus</span>.<span class="ͼ5">x</span> <span class="ͼ8">// выведет 1</span><br><span class="ͼ5">optimus</span>.<span class="ͼ5">run</span>() <span class="ͼ8">// приказывает Оптимусу еще раз бежать</span><br><span class="ͼ5">print</span> <span class="ͼ5">optimus</span>.<span class="ͼ5">x</span> <span class="ͼ8">// выведет 2</span><br></code></pre></p>
            </div>
            <div id="theory" class="category-content" style="display:none;">
                <p>Объектіге бағытталған бағдарламалау (OOP) — бағдарламаны бір-бірімен әрекеттесетін объектілердің жиынтығы ретінде қарастыратын тәсіл. Олардың әрқайсысының қасиеттері мен мінез-құлқы бар. Қарапайым сөздермен түсіндіруге тырыссаңыз, OOP кодты жазуды жылдамдатады және оны оқуға ыңғайлы етеді.Нақты объектінің мінез-құлқын оның класымен байланыстыру үшін объектілі-бағытталған бағдарламалау идеологиясы (OOP) жасалды. Адамдарға қоршаған әлемді белгілі бір классификацияға (мысалы, тірі және жансыз табиғатқа бөлу) сәйкес келетін объектілер ретінде қабылдау оңайырақ.</p>
                <p>Нақты объектінің мінез-құлқын оның класымен байланыстыру үшін объектілі-бағытталған бағдарламалау идеологиясы (OOP) жасалды. Адамдарға қоршаған әлемді белгілі бір классификацияға (мысалы, тірі және жансыз табиғатқа бөлу) сәйкес келетін объектілер ретінде қабылдау оңайырақ.</p>
                <p>Сізге OOP не үшін қажет?
                    OOP-қа дейін әзірлеуде басқа тәсіл қолданылды - процедуралық. Бағдарлама онда процедуралар мен функциялар жиынтығы ретінде ұсынылған - қажетті кіріс деректерімен кодтың белгілі бір блогын орындайтын ішкі бағдарламалар. Процедуралық бағдарламалау күрделі құрылымы жоқ жеңіл бағдарламалар үшін өте қолайлы. Бірақ егер код блоктары үлкен болса және жүздеген функциялар болса, олардың әрқайсысын өңдеуге және жаңа логика арқылы ойлауға тура келеді. Нәтиже көптеген нашар оқылатын, шатастырылған кодтар болуы мүмкін — «спагетти коды» немесе «кеспе».</p>
                    <p>Процедуралық бағдарламалаудан айырмашылығы, объектіге бағытталған бағдарламалау тек бір рет – объектіге өзгертулер енгізуге мүмкіндік береді. Бұл бағдарламаның негізгі элементі болып табылады. Барлық операциялар объектілер арасындағы өзара әрекеттесу ретінде көрсетіледі. Сонымен қатар, кодты оқуға және түсінуге болады, бағдарламаны масштабтау оңайырақ.

                        Объектіге бағытталған бағдарламалау мыналар үшін қолданылады:
                        
                       <li> ақпаратты құрылымдау және шатасуды болдырмау;</li>
                        <li>кейбір элементтердің басқалармен әрекеттесуін дәл анықтау;</li>
                        <li>бағдарламаны басқару мүмкіндігін арттыру;</li>
                        <li>әртүрлі тапсырмалар үшін кодты жылдамырақ масштабтау;</li>
                        <li>не жазылғанын жақсы түсіну;</li>
                        <li>дайын бағдарламаларды тиімдірек қолдау;</li>
                        барлық кодты қайта жазусыз өзгертулерді жүзеге асыру</p>
            </div>
        </div>
    </section>

    <footer id="contacts">
        <div class="container">
            <p>&copy; 2021 Объектно-ориентированное программирование. Все права защищены.</p>
            <div class="footer-links">
                <a href="#hero">О сервисе</a>
                <a href="#chapters">Главы</a>
                <a href="#authors">Авторы</a>
                <a href="#contacts">Контакты</a>
            </div>
        </div>
    </footer>
    <script src="script.js"></script>
</body>
</html>
